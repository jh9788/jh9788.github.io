---
layout: single
title:  "[프로그래머스, C++] 정수 삼각형"
typora-copy-images-to: ../../images/2023-10-15
Typora-root-url: ../../
categories: 
  - algorithm

---

## 분류: 동적계획법(DP)

**[문제 링크]( https://school.programmers.co.kr/learn/courses/30/lessons/43105)**





## 1. 문제

![스크린샷 2018-09-14 오후 5.44.19.png](https://grepp-programmers.s3.amazonaws.com/files/production/97ec02cc39/296a0863-a418-431d-9e8c-e57f7a9722ac.png)

위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다.

삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.



## 2. 풀이 아이디어

재귀함수를 사용하여 맨 아래층부터 위로 최댓값을 더해나가는 방식으로 구현 가능

하지만 동적계획법 문제이니까 이렇게만 풀면 시간초과가 날 것으로 예상

일단 아이디어를 위해 재귀적으로 적용해보고 효율성을 개선해 나가기로 함



## 3. 코드

### DP를 적용하지 않은 코드


```c++
#include <string>
#include <vector>
#include <iostream>
using namespace std;
int height;

int solve(int depth, int x, vector<vector<int>> &triangle){
    if(depth == height){
        return triangle[depth][x];
    }  
    
    return max(solve(depth+1, x, triangle) + triangle[depth][x],solve(depth+1, x+1, triangle) + triangle[depth][x]);
    
}

int solution(vector<vector<int>> triangle) {
    height = triangle.size()-1;
    
    int answer =   solve(0, 0, triangle);
    return answer;
}

```

![imgae-20231015한글](/images/2023-10-15/image-20231015한글.png)

예상대로 시간초과가 나는모습



### DP Recursive Top-Down 방식 적용

```c++
#include <string>
#include <vector>
#include <iostream>
using namespace std;

int height;

int dp[500][500] = {-1, };
int isMax[500][500] = {false, };

int solve(int depth, int x, vector<vector<int>> &triangle){

    if(depth == height){
        isMax[depth][x] = true;
        return triangle[depth][x];
    } 
    
    if(dp[depth][x] != -1 && isMax[depth][x]){// 추가로 dp에 들어있는값이 최대값이라는 조건 필요
        return dp[depth][x];
    }
    
    int left = solve(depth+1, x, triangle) + triangle[depth][x];
    int right = solve(depth+1, x+1, triangle) + triangle[depth][x];
    
    dp[depth][x] = max(left, right);
    isMax[depth][x] = true;

    return dp[depth][x];
    
}

int solution(vector<vector<int>> triangle) {
    height = triangle.size()-1;
    
    int answer = solve(0, 0, triangle);
    return answer;
}
```

![image-20231015155245097](/images/2023-10-15/image-20231015155245097.png)

DP를 적용해서 정확성 테스트는 다 통과했지만 여전히 효율성 테스트를 통과하지못함

역시 재귀함수는 오버헤드가 크기때문에 Memoization을 적용하는 것만으로는 부족해보임



### Bottom-Up 방식 적용(Non-recursive)

```c++
#include <string>
#include <vector>
#include <iostream>
using namespace std;

int dp[500][500] = {0, };
int solution(vector<vector<int>> triangle) {

    int height = triangle.size()-1;

    //bottom up 방식
    for(int i=height+1; i>0; i--){
        for(int j=0; j<height; j++){
            dp[i-1][j] = max(dp[i][j] + triangle[i-1][j], dp[i][j+1]+ triangle[i-1][j]);
        }
    }
    int answer = dp[0][0];
    return answer;
}
```

![image-20231015162207118](/images/2023-10-15/image-20231015162207118.png)


## 4. 코드 해설







## 5. 막혔던 부분





## 6. 배운점

vector의 깊은 복사

memset을 활용한 배열 초기화



## 7. 개선점

그래프 문제를 풀때 따로 그래프 자료구조를 안만들고 주어진 배열 그대로 사용하였는데

다음부터는 그래프 자료형을 따로 만든 후에 하는게 더 편할 것 같다.











